# Request For Comments (RFC)
[RFC]: #RFC

## Frontmatter
[frontmatter]: #frontmatter
```yaml
title: Project
stub: project
document: RFC
rfc: 0000
status: 0
maintainer: Firstname Lastname <email@address.tld>
contributors: [Firstname Lastname <email@address.tld>]
sponsor: Firstname Lastname <email@address.tld>
licenses: ["License X", "License Y"]
updated: YYYY-MMM-DD
```
<!--
A Request For Comments are appropriate whenever changes to an existing system are being proposed.
Please note, as opposed to the other document types that are versioned with
0000 at the end of their filename, RFCs are sequential and based on the project.
-->

## Summary
[summary]: #summary
<!--
One paragraph explanation of the feature.
-->

## Motivation
[motivation]: #motivation
<!--
Why are we doing this? What use cases does it support? What is the expected
outcome?

1. Write a summary of the motivation.
2. List all the specific use cases that your proposal is trying to address.
3. Where applicable, write from the perspective of the person who will be using
   the software, for example using the "Job story" format:

When ＿＿＿ , I want to ＿＿＿, so I can ＿＿＿.

+ **Example 1:** When I query a node for a list of transactions, I want to be
  able to sort them by date, so I can work with the most relevant ones.
+ **Example 2:** When I configure a node, I want to be able to control how much
  transaction history the node stores, so I can make sure I only store the data
  I need without incurring additional operational costs.
-->

## Detailed design
[design]: #design
<!--
This is the bulk of the RFC. Explain the design in enough detail for somebody
familiar with the IOTA and to understand, and for somebody familiar with Rust
to implement. This should get into specifics and corner-cases, and include
examples of how the feature is used.
-->

## Drawbacks
[drawbacks]: #drawbacks
<!--
Why should we *not* do this?
-->

## Rationale and alternatives
[rationale]: rationale
<!--
- Why is this design the best in the space of possible designs?
- What other designs have been considered and what is the rationale for not
  choosing them?
- What is the impact of not doing this?
-->

## Unresolved questions
[questions]: #questions
<!--
- What parts of the design do you expect to resolve through the RFC process
  before this gets merged?
- What parts of the design do you expect to resolve through the implementation
  of this feature before stabilization?
- What related issues do you consider out of scope for this RFC that could be
  addressed in the future independently of the solution that comes out of this
  RFC?
-->
